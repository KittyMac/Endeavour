import Foundation
import ArgumentParser
import Picaroon
import Flynn
import Hitch
import Spanker

public typealias DocumentUUID = Hitch
public typealias DocumentContent = Hitch
public typealias DocumentVersion = Int

public typealias UserUUID = Hitch
public typealias Error = HalfHitch

public class Endeavour: Actor {
    public static let shared = Endeavour()
    override private init() {}

    private var documents: [DocumentUUID: Document] = [:]

    private func _beNewDocument(userUUID: UserUUID,
                                content: Hitch?,
                                _ returnCallback: @escaping (DocumentInfo?, Error?) -> Void) {
        let document = Document(owner: userUUID,
                                content: content)
        document.beGetInfo(user: userUUID, self) { documentInfo, error in
            guard error == nil else { return returnCallback(nil, error) }
            guard let documentInfo = documentInfo else { return returnCallback(nil, "document info is missing") }
            self.documents[documentInfo.uuid] = document
            returnCallback(documentInfo, nil)
        }
    }

    private func _beNewDocument(userUUID: UserUUID,
                                named: Hitch?,
                                content: Hitch?,
                                _ returnCallback: @escaping (DocumentInfo?, Error?) -> Void) {
        let document = Document(owner: userUUID,
                                named: named,
                                content: content)
        document.beGetInfo(user: userUUID, self) { documentInfo, error in
            guard error == nil else { return returnCallback(nil, error) }
            guard let documentInfo = documentInfo else { return returnCallback(nil, "document info is missing") }
            self.documents[documentInfo.uuid] = document
            returnCallback(documentInfo, nil)
        }
    }

    private func _beJoinDocument(userUUID: UserUUID,
                                 documentUUID: DocumentUUID,
                                 _ returnCallback: @escaping (DocumentInfo?, Error?) -> Void) {
        guard let document = documents[documentUUID] else {
            return returnCallback(nil, "The document does not exist")
        }
        document.beAdd(waiting: userUUID,
                       self,
                       returnCallback)
    }

    private func _beLeaveDocument(userUUID: UserUUID,
                                  service: Service,
                                  documentUUID: DocumentUUID,
                                  _ returnCallback: @escaping (Error?) -> Void) {
        guard let document = documents[documentUUID] else {
            return returnCallback("The document does not exist")
        }

        document.beLeave(user: userUUID,
                         service: service,
                         self) { closed, error in
            if closed {
                self.documents[documentUUID] = nil
            }
            returnCallback(error)
        }
    }

    private func _bePushToDocument(userUUID: UserUUID,
                                   documentUUID: DocumentUUID,
                                   version: Int,
                                   updates: JsonElement,
                                   _ returnCallback: @escaping (Error?) -> Void) {
        guard let document = documents[documentUUID] else {
            return returnCallback("The document does not exist")
        }
        document.bePublish(peer: userUUID,
                          version: version,
                          updates: updates,
                          self,
                          returnCallback)
    }

    private func _beSubscribe(userUUID: UserUUID,
                              documentUUID: DocumentUUID,
                              service: Service) {
        guard let document = documents[documentUUID] else {
            return
        }
        document.beSubscribe(peer: userUUID,
                             service: service)
    }
}

// MARK: - Autogenerated by FlynnLint
// Contents of file after this marker will be overwritten as needed

extension Endeavour {

    @discardableResult
    public func beNewDocument(userUUID: UserUUID,
                              content: Hitch?,
                              _ sender: Actor,
                              _ callback: @escaping ((DocumentInfo?, Error?) -> Void)) -> Self {
        unsafeSend {
            self._beNewDocument(userUUID: userUUID, content: content) { arg0, arg1 in
                sender.unsafeSend {
                    callback(arg0, arg1)
                }
            }
        }
        return self
    }
    @discardableResult
    public func beNewDocument(userUUID: UserUUID,
                              named: Hitch?,
                              content: Hitch?,
                              _ sender: Actor,
                              _ callback: @escaping ((DocumentInfo?, Error?) -> Void)) -> Self {
        unsafeSend {
            self._beNewDocument(userUUID: userUUID, named: named, content: content) { arg0, arg1 in
                sender.unsafeSend {
                    callback(arg0, arg1)
                }
            }
        }
        return self
    }
    @discardableResult
    public func beJoinDocument(userUUID: UserUUID,
                               documentUUID: DocumentUUID,
                               _ sender: Actor,
                               _ callback: @escaping ((DocumentInfo?, Error?) -> Void)) -> Self {
        unsafeSend {
            self._beJoinDocument(userUUID: userUUID, documentUUID: documentUUID) { arg0, arg1 in
                sender.unsafeSend {
                    callback(arg0, arg1)
                }
            }
        }
        return self
    }
    @discardableResult
    public func beLeaveDocument(userUUID: UserUUID,
                                service: Service,
                                documentUUID: DocumentUUID,
                                _ sender: Actor,
                                _ callback: @escaping ((Error?) -> Void)) -> Self {
        unsafeSend {
            self._beLeaveDocument(userUUID: userUUID, service: service, documentUUID: documentUUID) { arg0 in
                sender.unsafeSend {
                    callback(arg0)
                }
            }
        }
        return self
    }
    @discardableResult
    public func bePushToDocument(userUUID: UserUUID,
                                 documentUUID: DocumentUUID,
                                 version: Int,
                                 updates: JsonElement,
                                 _ sender: Actor,
                                 _ callback: @escaping ((Error?) -> Void)) -> Self {
        unsafeSend {
            self._bePushToDocument(userUUID: userUUID, documentUUID: documentUUID, version: version, updates: updates) { arg0 in
                sender.unsafeSend {
                    callback(arg0)
                }
            }
        }
        return self
    }
    @discardableResult
    public func beSubscribe(userUUID: UserUUID,
                            documentUUID: DocumentUUID,
                            service: Service) -> Self {
        unsafeSend { self._beSubscribe(userUUID: userUUID, documentUUID: documentUUID, service: service) }
        return self
    }

}
